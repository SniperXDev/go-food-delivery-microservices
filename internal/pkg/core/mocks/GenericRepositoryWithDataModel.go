// Code generated by mockery v2.30.16. DO NOT EDIT.

package mocks

import (
	context "context"

	mock "github.com/stretchr/testify/mock"

	specification "github.com/mehdihadeli/go-ecommerce-microservices/internal/pkg/core/data/specification"

	utils "github.com/mehdihadeli/go-ecommerce-microservices/internal/pkg/utils"

	uuid "github.com/satori/go.uuid"
)

// GenericRepositoryWithDataModel is an autogenerated mock type for the GenericRepositoryWithDataModel type
type GenericRepositoryWithDataModel[TDataModel interface{}, TEntity interface{}] struct {
	mock.Mock
}

type GenericRepositoryWithDataModel_Expecter[TDataModel interface{}, TEntity interface{}] struct {
	mock *mock.Mock
}

func (_m *GenericRepositoryWithDataModel[TDataModel, TEntity]) EXPECT() *GenericRepositoryWithDataModel_Expecter[TDataModel, TEntity] {
	return &GenericRepositoryWithDataModel_Expecter[TDataModel, TEntity]{mock: &_m.Mock}
}

// Add provides a mock function with given fields: ctx, entity
func (_m *GenericRepositoryWithDataModel[TDataModel, TEntity]) Add(ctx context.Context, entity TEntity) error {
	ret := _m.Called(ctx, entity)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, TEntity) error); ok {
		r0 = rf(ctx, entity)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GenericRepositoryWithDataModel_Add_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Add'
type GenericRepositoryWithDataModel_Add_Call[TDataModel interface{}, TEntity interface{}] struct {
	*mock.Call
}

// Add is a helper method to define mock.On call
//   - ctx context.Context
//   - entity TEntity
func (_e *GenericRepositoryWithDataModel_Expecter[TDataModel, TEntity]) Add(ctx interface{}, entity interface{}) *GenericRepositoryWithDataModel_Add_Call[TDataModel, TEntity] {
	return &GenericRepositoryWithDataModel_Add_Call[TDataModel, TEntity]{Call: _e.mock.On("Add", ctx, entity)}
}

func (_c *GenericRepositoryWithDataModel_Add_Call[TDataModel, TEntity]) Run(run func(ctx context.Context, entity TEntity)) *GenericRepositoryWithDataModel_Add_Call[TDataModel, TEntity] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(TEntity))
	})
	return _c
}

func (_c *GenericRepositoryWithDataModel_Add_Call[TDataModel, TEntity]) Return(_a0 error) *GenericRepositoryWithDataModel_Add_Call[TDataModel, TEntity] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *GenericRepositoryWithDataModel_Add_Call[TDataModel, TEntity]) RunAndReturn(run func(context.Context, TEntity) error) *GenericRepositoryWithDataModel_Add_Call[TDataModel, TEntity] {
	_c.Call.Return(run)
	return _c
}

// AddAll provides a mock function with given fields: ctx, entities
func (_m *GenericRepositoryWithDataModel[TDataModel, TEntity]) AddAll(ctx context.Context, entities []TEntity) error {
	ret := _m.Called(ctx, entities)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []TEntity) error); ok {
		r0 = rf(ctx, entities)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GenericRepositoryWithDataModel_AddAll_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddAll'
type GenericRepositoryWithDataModel_AddAll_Call[TDataModel interface{}, TEntity interface{}] struct {
	*mock.Call
}

// AddAll is a helper method to define mock.On call
//   - ctx context.Context
//   - entities []TEntity
func (_e *GenericRepositoryWithDataModel_Expecter[TDataModel, TEntity]) AddAll(ctx interface{}, entities interface{}) *GenericRepositoryWithDataModel_AddAll_Call[TDataModel, TEntity] {
	return &GenericRepositoryWithDataModel_AddAll_Call[TDataModel, TEntity]{Call: _e.mock.On("AddAll", ctx, entities)}
}

func (_c *GenericRepositoryWithDataModel_AddAll_Call[TDataModel, TEntity]) Run(run func(ctx context.Context, entities []TEntity)) *GenericRepositoryWithDataModel_AddAll_Call[TDataModel, TEntity] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]TEntity))
	})
	return _c
}

func (_c *GenericRepositoryWithDataModel_AddAll_Call[TDataModel, TEntity]) Return(_a0 error) *GenericRepositoryWithDataModel_AddAll_Call[TDataModel, TEntity] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *GenericRepositoryWithDataModel_AddAll_Call[TDataModel, TEntity]) RunAndReturn(run func(context.Context, []TEntity) error) *GenericRepositoryWithDataModel_AddAll_Call[TDataModel, TEntity] {
	_c.Call.Return(run)
	return _c
}

// Count provides a mock function with given fields: ctx
func (_m *GenericRepositoryWithDataModel[TDataModel, TEntity]) Count(ctx context.Context) int64 {
	ret := _m.Called(ctx)

	var r0 int64
	if rf, ok := ret.Get(0).(func(context.Context) int64); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(int64)
	}

	return r0
}

// GenericRepositoryWithDataModel_Count_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Count'
type GenericRepositoryWithDataModel_Count_Call[TDataModel interface{}, TEntity interface{}] struct {
	*mock.Call
}

// Count is a helper method to define mock.On call
//   - ctx context.Context
func (_e *GenericRepositoryWithDataModel_Expecter[TDataModel, TEntity]) Count(ctx interface{}) *GenericRepositoryWithDataModel_Count_Call[TDataModel, TEntity] {
	return &GenericRepositoryWithDataModel_Count_Call[TDataModel, TEntity]{Call: _e.mock.On("Count", ctx)}
}

func (_c *GenericRepositoryWithDataModel_Count_Call[TDataModel, TEntity]) Run(run func(ctx context.Context)) *GenericRepositoryWithDataModel_Count_Call[TDataModel, TEntity] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *GenericRepositoryWithDataModel_Count_Call[TDataModel, TEntity]) Return(_a0 int64) *GenericRepositoryWithDataModel_Count_Call[TDataModel, TEntity] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *GenericRepositoryWithDataModel_Count_Call[TDataModel, TEntity]) RunAndReturn(run func(context.Context) int64) *GenericRepositoryWithDataModel_Count_Call[TDataModel, TEntity] {
	_c.Call.Return(run)
	return _c
}

// Delete provides a mock function with given fields: ctx, id
func (_m *GenericRepositoryWithDataModel[TDataModel, TEntity]) Delete(ctx context.Context, id uuid.UUID) error {
	ret := _m.Called(ctx, id)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) error); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GenericRepositoryWithDataModel_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type GenericRepositoryWithDataModel_Delete_Call[TDataModel interface{}, TEntity interface{}] struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - ctx context.Context
//   - id uuid.UUID
func (_e *GenericRepositoryWithDataModel_Expecter[TDataModel, TEntity]) Delete(ctx interface{}, id interface{}) *GenericRepositoryWithDataModel_Delete_Call[TDataModel, TEntity] {
	return &GenericRepositoryWithDataModel_Delete_Call[TDataModel, TEntity]{Call: _e.mock.On("Delete", ctx, id)}
}

func (_c *GenericRepositoryWithDataModel_Delete_Call[TDataModel, TEntity]) Run(run func(ctx context.Context, id uuid.UUID)) *GenericRepositoryWithDataModel_Delete_Call[TDataModel, TEntity] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *GenericRepositoryWithDataModel_Delete_Call[TDataModel, TEntity]) Return(_a0 error) *GenericRepositoryWithDataModel_Delete_Call[TDataModel, TEntity] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *GenericRepositoryWithDataModel_Delete_Call[TDataModel, TEntity]) RunAndReturn(run func(context.Context, uuid.UUID) error) *GenericRepositoryWithDataModel_Delete_Call[TDataModel, TEntity] {
	_c.Call.Return(run)
	return _c
}

// Find provides a mock function with given fields: ctx, _a1
func (_m *GenericRepositoryWithDataModel[TDataModel, TEntity]) Find(ctx context.Context, _a1 specification.Specification) ([]TEntity, error) {
	ret := _m.Called(ctx, _a1)

	var r0 []TEntity
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, specification.Specification) ([]TEntity, error)); ok {
		return rf(ctx, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, specification.Specification) []TEntity); ok {
		r0 = rf(ctx, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]TEntity)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, specification.Specification) error); ok {
		r1 = rf(ctx, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GenericRepositoryWithDataModel_Find_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Find'
type GenericRepositoryWithDataModel_Find_Call[TDataModel interface{}, TEntity interface{}] struct {
	*mock.Call
}

// Find is a helper method to define mock.On call
//   - ctx context.Context
//   - _a1 specification.Specification
func (_e *GenericRepositoryWithDataModel_Expecter[TDataModel, TEntity]) Find(ctx interface{}, _a1 interface{}) *GenericRepositoryWithDataModel_Find_Call[TDataModel, TEntity] {
	return &GenericRepositoryWithDataModel_Find_Call[TDataModel, TEntity]{Call: _e.mock.On("Find", ctx, _a1)}
}

func (_c *GenericRepositoryWithDataModel_Find_Call[TDataModel, TEntity]) Run(run func(ctx context.Context, _a1 specification.Specification)) *GenericRepositoryWithDataModel_Find_Call[TDataModel, TEntity] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(specification.Specification))
	})
	return _c
}

func (_c *GenericRepositoryWithDataModel_Find_Call[TDataModel, TEntity]) Return(_a0 []TEntity, _a1 error) *GenericRepositoryWithDataModel_Find_Call[TDataModel, TEntity] {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *GenericRepositoryWithDataModel_Find_Call[TDataModel, TEntity]) RunAndReturn(run func(context.Context, specification.Specification) ([]TEntity, error)) *GenericRepositoryWithDataModel_Find_Call[TDataModel, TEntity] {
	_c.Call.Return(run)
	return _c
}

// FirstOrDefault provides a mock function with given fields: ctx, filters
func (_m *GenericRepositoryWithDataModel[TDataModel, TEntity]) FirstOrDefault(ctx context.Context, filters map[string]interface{}) (TEntity, error) {
	ret := _m.Called(ctx, filters)

	var r0 TEntity
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, map[string]interface{}) (TEntity, error)); ok {
		return rf(ctx, filters)
	}
	if rf, ok := ret.Get(0).(func(context.Context, map[string]interface{}) TEntity); ok {
		r0 = rf(ctx, filters)
	} else {
		r0 = ret.Get(0).(TEntity)
	}

	if rf, ok := ret.Get(1).(func(context.Context, map[string]interface{}) error); ok {
		r1 = rf(ctx, filters)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GenericRepositoryWithDataModel_FirstOrDefault_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FirstOrDefault'
type GenericRepositoryWithDataModel_FirstOrDefault_Call[TDataModel interface{}, TEntity interface{}] struct {
	*mock.Call
}

// FirstOrDefault is a helper method to define mock.On call
//   - ctx context.Context
//   - filters map[string]interface{}
func (_e *GenericRepositoryWithDataModel_Expecter[TDataModel, TEntity]) FirstOrDefault(ctx interface{}, filters interface{}) *GenericRepositoryWithDataModel_FirstOrDefault_Call[TDataModel, TEntity] {
	return &GenericRepositoryWithDataModel_FirstOrDefault_Call[TDataModel, TEntity]{Call: _e.mock.On("FirstOrDefault", ctx, filters)}
}

func (_c *GenericRepositoryWithDataModel_FirstOrDefault_Call[TDataModel, TEntity]) Run(run func(ctx context.Context, filters map[string]interface{})) *GenericRepositoryWithDataModel_FirstOrDefault_Call[TDataModel, TEntity] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(map[string]interface{}))
	})
	return _c
}

func (_c *GenericRepositoryWithDataModel_FirstOrDefault_Call[TDataModel, TEntity]) Return(_a0 TEntity, _a1 error) *GenericRepositoryWithDataModel_FirstOrDefault_Call[TDataModel, TEntity] {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *GenericRepositoryWithDataModel_FirstOrDefault_Call[TDataModel, TEntity]) RunAndReturn(run func(context.Context, map[string]interface{}) (TEntity, error)) *GenericRepositoryWithDataModel_FirstOrDefault_Call[TDataModel, TEntity] {
	_c.Call.Return(run)
	return _c
}

// GetAll provides a mock function with given fields: ctx, listQuery
func (_m *GenericRepositoryWithDataModel[TDataModel, TEntity]) GetAll(ctx context.Context, listQuery *utils.ListQuery) (*utils.ListResult[TEntity], error) {
	ret := _m.Called(ctx, listQuery)

	var r0 *utils.ListResult[TEntity]
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *utils.ListQuery) (*utils.ListResult[TEntity], error)); ok {
		return rf(ctx, listQuery)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *utils.ListQuery) *utils.ListResult[TEntity]); ok {
		r0 = rf(ctx, listQuery)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*utils.ListResult[TEntity])
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *utils.ListQuery) error); ok {
		r1 = rf(ctx, listQuery)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GenericRepositoryWithDataModel_GetAll_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAll'
type GenericRepositoryWithDataModel_GetAll_Call[TDataModel interface{}, TEntity interface{}] struct {
	*mock.Call
}

// GetAll is a helper method to define mock.On call
//   - ctx context.Context
//   - listQuery *utils.ListQuery
func (_e *GenericRepositoryWithDataModel_Expecter[TDataModel, TEntity]) GetAll(ctx interface{}, listQuery interface{}) *GenericRepositoryWithDataModel_GetAll_Call[TDataModel, TEntity] {
	return &GenericRepositoryWithDataModel_GetAll_Call[TDataModel, TEntity]{Call: _e.mock.On("GetAll", ctx, listQuery)}
}

func (_c *GenericRepositoryWithDataModel_GetAll_Call[TDataModel, TEntity]) Run(run func(ctx context.Context, listQuery *utils.ListQuery)) *GenericRepositoryWithDataModel_GetAll_Call[TDataModel, TEntity] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*utils.ListQuery))
	})
	return _c
}

func (_c *GenericRepositoryWithDataModel_GetAll_Call[TDataModel, TEntity]) Return(_a0 *utils.ListResult[TEntity], _a1 error) *GenericRepositoryWithDataModel_GetAll_Call[TDataModel, TEntity] {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *GenericRepositoryWithDataModel_GetAll_Call[TDataModel, TEntity]) RunAndReturn(run func(context.Context, *utils.ListQuery) (*utils.ListResult[TEntity], error)) *GenericRepositoryWithDataModel_GetAll_Call[TDataModel, TEntity] {
	_c.Call.Return(run)
	return _c
}

// GetByFilter provides a mock function with given fields: ctx, filters
func (_m *GenericRepositoryWithDataModel[TDataModel, TEntity]) GetByFilter(ctx context.Context, filters map[string]interface{}) ([]TEntity, error) {
	ret := _m.Called(ctx, filters)

	var r0 []TEntity
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, map[string]interface{}) ([]TEntity, error)); ok {
		return rf(ctx, filters)
	}
	if rf, ok := ret.Get(0).(func(context.Context, map[string]interface{}) []TEntity); ok {
		r0 = rf(ctx, filters)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]TEntity)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, map[string]interface{}) error); ok {
		r1 = rf(ctx, filters)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GenericRepositoryWithDataModel_GetByFilter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByFilter'
type GenericRepositoryWithDataModel_GetByFilter_Call[TDataModel interface{}, TEntity interface{}] struct {
	*mock.Call
}

// GetByFilter is a helper method to define mock.On call
//   - ctx context.Context
//   - filters map[string]interface{}
func (_e *GenericRepositoryWithDataModel_Expecter[TDataModel, TEntity]) GetByFilter(ctx interface{}, filters interface{}) *GenericRepositoryWithDataModel_GetByFilter_Call[TDataModel, TEntity] {
	return &GenericRepositoryWithDataModel_GetByFilter_Call[TDataModel, TEntity]{Call: _e.mock.On("GetByFilter", ctx, filters)}
}

func (_c *GenericRepositoryWithDataModel_GetByFilter_Call[TDataModel, TEntity]) Run(run func(ctx context.Context, filters map[string]interface{})) *GenericRepositoryWithDataModel_GetByFilter_Call[TDataModel, TEntity] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(map[string]interface{}))
	})
	return _c
}

func (_c *GenericRepositoryWithDataModel_GetByFilter_Call[TDataModel, TEntity]) Return(_a0 []TEntity, _a1 error) *GenericRepositoryWithDataModel_GetByFilter_Call[TDataModel, TEntity] {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *GenericRepositoryWithDataModel_GetByFilter_Call[TDataModel, TEntity]) RunAndReturn(run func(context.Context, map[string]interface{}) ([]TEntity, error)) *GenericRepositoryWithDataModel_GetByFilter_Call[TDataModel, TEntity] {
	_c.Call.Return(run)
	return _c
}

// GetByFuncFilter provides a mock function with given fields: ctx, filterFunc
func (_m *GenericRepositoryWithDataModel[TDataModel, TEntity]) GetByFuncFilter(ctx context.Context, filterFunc func(TEntity) bool) ([]TEntity, error) {
	ret := _m.Called(ctx, filterFunc)

	var r0 []TEntity
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, func(TEntity) bool) ([]TEntity, error)); ok {
		return rf(ctx, filterFunc)
	}
	if rf, ok := ret.Get(0).(func(context.Context, func(TEntity) bool) []TEntity); ok {
		r0 = rf(ctx, filterFunc)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]TEntity)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, func(TEntity) bool) error); ok {
		r1 = rf(ctx, filterFunc)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GenericRepositoryWithDataModel_GetByFuncFilter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByFuncFilter'
type GenericRepositoryWithDataModel_GetByFuncFilter_Call[TDataModel interface{}, TEntity interface{}] struct {
	*mock.Call
}

// GetByFuncFilter is a helper method to define mock.On call
//   - ctx context.Context
//   - filterFunc func(TEntity) bool
func (_e *GenericRepositoryWithDataModel_Expecter[TDataModel, TEntity]) GetByFuncFilter(ctx interface{}, filterFunc interface{}) *GenericRepositoryWithDataModel_GetByFuncFilter_Call[TDataModel, TEntity] {
	return &GenericRepositoryWithDataModel_GetByFuncFilter_Call[TDataModel, TEntity]{Call: _e.mock.On("GetByFuncFilter", ctx, filterFunc)}
}

func (_c *GenericRepositoryWithDataModel_GetByFuncFilter_Call[TDataModel, TEntity]) Run(run func(ctx context.Context, filterFunc func(TEntity) bool)) *GenericRepositoryWithDataModel_GetByFuncFilter_Call[TDataModel, TEntity] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(func(TEntity) bool))
	})
	return _c
}

func (_c *GenericRepositoryWithDataModel_GetByFuncFilter_Call[TDataModel, TEntity]) Return(_a0 []TEntity, _a1 error) *GenericRepositoryWithDataModel_GetByFuncFilter_Call[TDataModel, TEntity] {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *GenericRepositoryWithDataModel_GetByFuncFilter_Call[TDataModel, TEntity]) RunAndReturn(run func(context.Context, func(TEntity) bool) ([]TEntity, error)) *GenericRepositoryWithDataModel_GetByFuncFilter_Call[TDataModel, TEntity] {
	_c.Call.Return(run)
	return _c
}

// GetById provides a mock function with given fields: ctx, id
func (_m *GenericRepositoryWithDataModel[TDataModel, TEntity]) GetById(ctx context.Context, id uuid.UUID) (TEntity, error) {
	ret := _m.Called(ctx, id)

	var r0 TEntity
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) (TEntity, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) TEntity); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Get(0).(TEntity)
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GenericRepositoryWithDataModel_GetById_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetById'
type GenericRepositoryWithDataModel_GetById_Call[TDataModel interface{}, TEntity interface{}] struct {
	*mock.Call
}

// GetById is a helper method to define mock.On call
//   - ctx context.Context
//   - id uuid.UUID
func (_e *GenericRepositoryWithDataModel_Expecter[TDataModel, TEntity]) GetById(ctx interface{}, id interface{}) *GenericRepositoryWithDataModel_GetById_Call[TDataModel, TEntity] {
	return &GenericRepositoryWithDataModel_GetById_Call[TDataModel, TEntity]{Call: _e.mock.On("GetById", ctx, id)}
}

func (_c *GenericRepositoryWithDataModel_GetById_Call[TDataModel, TEntity]) Run(run func(ctx context.Context, id uuid.UUID)) *GenericRepositoryWithDataModel_GetById_Call[TDataModel, TEntity] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *GenericRepositoryWithDataModel_GetById_Call[TDataModel, TEntity]) Return(_a0 TEntity, _a1 error) *GenericRepositoryWithDataModel_GetById_Call[TDataModel, TEntity] {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *GenericRepositoryWithDataModel_GetById_Call[TDataModel, TEntity]) RunAndReturn(run func(context.Context, uuid.UUID) (TEntity, error)) *GenericRepositoryWithDataModel_GetById_Call[TDataModel, TEntity] {
	_c.Call.Return(run)
	return _c
}

// Search provides a mock function with given fields: ctx, searchTerm, listQuery
func (_m *GenericRepositoryWithDataModel[TDataModel, TEntity]) Search(ctx context.Context, searchTerm string, listQuery *utils.ListQuery) (*utils.ListResult[TEntity], error) {
	ret := _m.Called(ctx, searchTerm, listQuery)

	var r0 *utils.ListResult[TEntity]
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *utils.ListQuery) (*utils.ListResult[TEntity], error)); ok {
		return rf(ctx, searchTerm, listQuery)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *utils.ListQuery) *utils.ListResult[TEntity]); ok {
		r0 = rf(ctx, searchTerm, listQuery)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*utils.ListResult[TEntity])
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *utils.ListQuery) error); ok {
		r1 = rf(ctx, searchTerm, listQuery)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GenericRepositoryWithDataModel_Search_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Search'
type GenericRepositoryWithDataModel_Search_Call[TDataModel interface{}, TEntity interface{}] struct {
	*mock.Call
}

// Search is a helper method to define mock.On call
//   - ctx context.Context
//   - searchTerm string
//   - listQuery *utils.ListQuery
func (_e *GenericRepositoryWithDataModel_Expecter[TDataModel, TEntity]) Search(ctx interface{}, searchTerm interface{}, listQuery interface{}) *GenericRepositoryWithDataModel_Search_Call[TDataModel, TEntity] {
	return &GenericRepositoryWithDataModel_Search_Call[TDataModel, TEntity]{Call: _e.mock.On("Search", ctx, searchTerm, listQuery)}
}

func (_c *GenericRepositoryWithDataModel_Search_Call[TDataModel, TEntity]) Run(run func(ctx context.Context, searchTerm string, listQuery *utils.ListQuery)) *GenericRepositoryWithDataModel_Search_Call[TDataModel, TEntity] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*utils.ListQuery))
	})
	return _c
}

func (_c *GenericRepositoryWithDataModel_Search_Call[TDataModel, TEntity]) Return(_a0 *utils.ListResult[TEntity], _a1 error) *GenericRepositoryWithDataModel_Search_Call[TDataModel, TEntity] {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *GenericRepositoryWithDataModel_Search_Call[TDataModel, TEntity]) RunAndReturn(run func(context.Context, string, *utils.ListQuery) (*utils.ListResult[TEntity], error)) *GenericRepositoryWithDataModel_Search_Call[TDataModel, TEntity] {
	_c.Call.Return(run)
	return _c
}

// SkipTake provides a mock function with given fields: ctx, skip, take
func (_m *GenericRepositoryWithDataModel[TDataModel, TEntity]) SkipTake(ctx context.Context, skip int, take int) ([]TEntity, error) {
	ret := _m.Called(ctx, skip, take)

	var r0 []TEntity
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int, int) ([]TEntity, error)); ok {
		return rf(ctx, skip, take)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, int) []TEntity); ok {
		r0 = rf(ctx, skip, take)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]TEntity)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, int) error); ok {
		r1 = rf(ctx, skip, take)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GenericRepositoryWithDataModel_SkipTake_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SkipTake'
type GenericRepositoryWithDataModel_SkipTake_Call[TDataModel interface{}, TEntity interface{}] struct {
	*mock.Call
}

// SkipTake is a helper method to define mock.On call
//   - ctx context.Context
//   - skip int
//   - take int
func (_e *GenericRepositoryWithDataModel_Expecter[TDataModel, TEntity]) SkipTake(ctx interface{}, skip interface{}, take interface{}) *GenericRepositoryWithDataModel_SkipTake_Call[TDataModel, TEntity] {
	return &GenericRepositoryWithDataModel_SkipTake_Call[TDataModel, TEntity]{Call: _e.mock.On("SkipTake", ctx, skip, take)}
}

func (_c *GenericRepositoryWithDataModel_SkipTake_Call[TDataModel, TEntity]) Run(run func(ctx context.Context, skip int, take int)) *GenericRepositoryWithDataModel_SkipTake_Call[TDataModel, TEntity] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(int))
	})
	return _c
}

func (_c *GenericRepositoryWithDataModel_SkipTake_Call[TDataModel, TEntity]) Return(_a0 []TEntity, _a1 error) *GenericRepositoryWithDataModel_SkipTake_Call[TDataModel, TEntity] {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *GenericRepositoryWithDataModel_SkipTake_Call[TDataModel, TEntity]) RunAndReturn(run func(context.Context, int, int) ([]TEntity, error)) *GenericRepositoryWithDataModel_SkipTake_Call[TDataModel, TEntity] {
	_c.Call.Return(run)
	return _c
}

// Update provides a mock function with given fields: ctx, entity
func (_m *GenericRepositoryWithDataModel[TDataModel, TEntity]) Update(ctx context.Context, entity TEntity) error {
	ret := _m.Called(ctx, entity)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, TEntity) error); ok {
		r0 = rf(ctx, entity)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GenericRepositoryWithDataModel_Update_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Update'
type GenericRepositoryWithDataModel_Update_Call[TDataModel interface{}, TEntity interface{}] struct {
	*mock.Call
}

// Update is a helper method to define mock.On call
//   - ctx context.Context
//   - entity TEntity
func (_e *GenericRepositoryWithDataModel_Expecter[TDataModel, TEntity]) Update(ctx interface{}, entity interface{}) *GenericRepositoryWithDataModel_Update_Call[TDataModel, TEntity] {
	return &GenericRepositoryWithDataModel_Update_Call[TDataModel, TEntity]{Call: _e.mock.On("Update", ctx, entity)}
}

func (_c *GenericRepositoryWithDataModel_Update_Call[TDataModel, TEntity]) Run(run func(ctx context.Context, entity TEntity)) *GenericRepositoryWithDataModel_Update_Call[TDataModel, TEntity] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(TEntity))
	})
	return _c
}

func (_c *GenericRepositoryWithDataModel_Update_Call[TDataModel, TEntity]) Return(_a0 error) *GenericRepositoryWithDataModel_Update_Call[TDataModel, TEntity] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *GenericRepositoryWithDataModel_Update_Call[TDataModel, TEntity]) RunAndReturn(run func(context.Context, TEntity) error) *GenericRepositoryWithDataModel_Update_Call[TDataModel, TEntity] {
	_c.Call.Return(run)
	return _c
}

// UpdateAll provides a mock function with given fields: ctx, entities
func (_m *GenericRepositoryWithDataModel[TDataModel, TEntity]) UpdateAll(ctx context.Context, entities []TEntity) error {
	ret := _m.Called(ctx, entities)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []TEntity) error); ok {
		r0 = rf(ctx, entities)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GenericRepositoryWithDataModel_UpdateAll_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateAll'
type GenericRepositoryWithDataModel_UpdateAll_Call[TDataModel interface{}, TEntity interface{}] struct {
	*mock.Call
}

// UpdateAll is a helper method to define mock.On call
//   - ctx context.Context
//   - entities []TEntity
func (_e *GenericRepositoryWithDataModel_Expecter[TDataModel, TEntity]) UpdateAll(ctx interface{}, entities interface{}) *GenericRepositoryWithDataModel_UpdateAll_Call[TDataModel, TEntity] {
	return &GenericRepositoryWithDataModel_UpdateAll_Call[TDataModel, TEntity]{Call: _e.mock.On("UpdateAll", ctx, entities)}
}

func (_c *GenericRepositoryWithDataModel_UpdateAll_Call[TDataModel, TEntity]) Run(run func(ctx context.Context, entities []TEntity)) *GenericRepositoryWithDataModel_UpdateAll_Call[TDataModel, TEntity] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]TEntity))
	})
	return _c
}

func (_c *GenericRepositoryWithDataModel_UpdateAll_Call[TDataModel, TEntity]) Return(_a0 error) *GenericRepositoryWithDataModel_UpdateAll_Call[TDataModel, TEntity] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *GenericRepositoryWithDataModel_UpdateAll_Call[TDataModel, TEntity]) RunAndReturn(run func(context.Context, []TEntity) error) *GenericRepositoryWithDataModel_UpdateAll_Call[TDataModel, TEntity] {
	_c.Call.Return(run)
	return _c
}

// NewGenericRepositoryWithDataModel creates a new instance of GenericRepositoryWithDataModel. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewGenericRepositoryWithDataModel[TDataModel interface{}, TEntity interface{}](t interface {
	mock.TestingT
	Cleanup(func())
}) *GenericRepositoryWithDataModel[TDataModel, TEntity] {
	mock := &GenericRepositoryWithDataModel[TDataModel, TEntity]{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
